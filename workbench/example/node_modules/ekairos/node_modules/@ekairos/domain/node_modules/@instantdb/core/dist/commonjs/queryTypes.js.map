{"version":3,"file":"queryTypes.js","sourceRoot":"","sources":["../../src/queryTypes.ts"],"names":[],"mappings":";AAAA,QAAQ;AACR,QAAQ","sourcesContent":["// Query\n// -----\n\nimport type {\n  EntitiesDef,\n  IContainEntitiesAndLinks,\n  InstantGraph,\n  LinkAttrDef,\n  RuleParams,\n  ResolveAttrs,\n  ResolveEntityAttrs,\n  DataAttrDef,\n  AttrsDefs,\n  EntityDefFromSchema,\n  InstantUnknownSchemaDef,\n} from './schemaTypes.ts';\n\ntype BuiltIn = Date | Function | Error | RegExp;\n\ntype Primitive = string | number | boolean | symbol | null | undefined;\n\nexport type Expand<T> = T extends BuiltIn | Primitive\n  ? T\n  : T extends object\n    ? T extends infer O\n      ? { [K in keyof O]: Expand<O[K]> }\n      : never\n    : T;\n\n// NonEmpty disallows {}, so that you must provide at least one field\nexport type NonEmpty<T> = {\n  [K in keyof T]-?: Required<Pick<T, K>>;\n}[keyof T];\n\ntype BaseWhereClauseValueComplex<V> = {\n  /** @deprecated use `$in` instead of `in` */\n  in?: V[];\n  $in?: V[];\n  /** @deprecated use `$ne` instead of `not` */\n  $not?: V;\n  $ne?: V;\n  $gt?: V;\n  $lt?: V;\n  $gte?: V;\n  $lte?: V;\n};\n\ntype IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;\n\ntype WhereClauseValueComplex<V, R, I> = BaseWhereClauseValueComplex<V> &\n  (IsAny<V> extends true\n    ? {\n        $ilike?: string;\n        $like?: string;\n        $isNull?: boolean;\n      }\n    : (V extends string\n        ? {\n            $like?: string;\n          }\n        : {}) &\n        (R extends false\n          ? {\n              $isNull?: boolean;\n            }\n          : {}) &\n        (I extends true\n          ? {\n              $ilike?: string;\n            }\n          : {}));\n\n// Make type display better\ntype WhereClauseValue<\n  D extends DataAttrDef<string | number | boolean, boolean, boolean>,\n> =\n  D extends DataAttrDef<infer V, infer R, infer I>\n    ?\n        | (IsAny<V> extends true ? string | number | boolean : V)\n        | NonEmpty<WhereClauseValueComplex<V, R, I>>\n    : never;\n\ntype WhereClauseColumnEntries<\n  T extends {\n    [key: string]: DataAttrDef<any, boolean, boolean>;\n  },\n> = {\n  [key in keyof T]?: WhereClauseValue<T[key]>;\n};\n\ntype WhereClauseComboEntries<\n  T extends Record<any, DataAttrDef<any, boolean, boolean>>,\n> = {\n  or?: WhereClauses<T>[] | WhereClauseValue<DataAttrDef<any, false, true>>;\n  and?: WhereClauses<T>[] | WhereClauseValue<DataAttrDef<any, false, true>>;\n};\n\ntype WhereClauses<T extends Record<any, DataAttrDef<any, boolean, boolean>>> = (\n  | WhereClauseComboEntries<T>\n  | (WhereClauseComboEntries<T> & WhereClauseColumnEntries<T>)\n) & {\n  id?: WhereClauseValue<DataAttrDef<string, false, true>>;\n  [key: `${string}.${string}`]: WhereClauseValue<DataAttrDef<any, false, true>>;\n};\n\n/**\n * A tuple representing a cursor.\n * These should not be constructed manually. The current format\n * is an implementation detail that may change in the future.\n * Use the `endCursor` or `startCursor` from the PageInfoResponse as the\n * `before` or `after` field in the query options.\n */\ntype Cursor = [string, string, any, number];\n\ntype Direction = 'asc' | 'desc';\n\ntype IndexedKeys<Attrs extends AttrsDefs> = {\n  [K in keyof Attrs]: Attrs[K] extends DataAttrDef<any, any, infer IsIndexed>\n    ? IsIndexed extends true\n      ? K\n      : never\n    : never;\n}[keyof Attrs];\n\nexport type Order<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> =\n  IndexedKeys<Schema['entities'][EntityName]['attrs']> extends never\n    ? {\n        serverCreatedAt?: Direction;\n      }\n    : {\n        [K in IndexedKeys<Schema['entities'][EntityName]['attrs']>]?: Direction;\n      } & {\n        serverCreatedAt?: Direction;\n      };\n\ntype $Option<\n  S extends IContainEntitiesAndLinks<any, any>,\n  K extends keyof S['entities'],\n> = {\n  $?: {\n    where?: WhereClauses<EntityDefFromSchema<S, K>>;\n    order?: Order<S, K>;\n    limit?: number;\n    last?: number;\n    first?: number;\n    offset?: number;\n    after?: Cursor;\n    before?: Cursor;\n    fields?: InstaQLFields<S, K>;\n  };\n};\n\ntype NamespaceVal =\n  | $Option<IContainEntitiesAndLinks<any, any>, keyof EntitiesDef>\n  | ($Option<IContainEntitiesAndLinks<any, any>, keyof EntitiesDef> & Subquery);\n\ntype Subquery = { [namespace: string]: NamespaceVal };\n\ninterface Query {\n  [namespace: string]: NamespaceVal;\n}\n\ntype InstantObject = {\n  id: string;\n  [prop: string]: any;\n};\n\ntype ResponseObject<K, Schema> = K extends keyof Schema\n  ? { id: string } & Schema[K]\n  : InstantObject;\n\ntype IsEmptyObject<T> = T extends Record<string, never> ? true : false;\n\ntype ResponseOf<Q, Schema> = {\n  [K in keyof Q]: IsEmptyObject<Q[K]> extends true\n    ? ResponseObject<K, Schema>[]\n    : (ResponseOf<Q[K], Schema> & ResponseObject<K, Schema>)[];\n};\n\ntype Remove$<T> = T extends object\n  ? { [K in keyof T as Exclude<K, '$'>]: Remove$<T[K]> }\n  : T;\n\ntype Remove$NonRecursive<T> = T extends object\n  ? { [K in keyof T as Exclude<K, '$'>]: T[K] }\n  : T;\n\ntype QueryResponse<\n  Q,\n  Schema,\n  WithCardinalityInference extends boolean = false,\n  UseDates extends boolean = false,\n> =\n  Schema extends InstantGraph<infer E, any>\n    ? InstaQLQueryResult<E, Q, WithCardinalityInference, UseDates>\n    : ResponseOf<{ [K in keyof Q]: Remove$<Q[K]> }, Schema>;\n\ntype InstaQLResponse<Schema, Q, UseDates extends boolean = false> =\n  Schema extends IContainEntitiesAndLinks<any, any>\n    ? InstaQLResult<Schema, Q, UseDates>\n    : never;\n\ntype PageInfoResponse<T> = {\n  [K in keyof T]: {\n    startCursor: Cursor;\n    endCursor: Cursor;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n  };\n};\n\n/**\n * (XXX)\n * https://github.com/microsoft/TypeScript/issues/26051\n *\n * Typescript can permit extra keys when a generic extends a type.\n *\n * For some reason, it makes it possible to write a query like so:\n *\n * dummyQuery({\n *  users: {\n *    $: { where: { \"foo\": 1 } },\n *    posts: {\n *      $: { \"far\": {} }\n *    }\n *  }\n *\n *  The problem: $: { \"far\": {} }\n *\n *  This passes, when it should in reality fail. I don't know why\n *  adding `Exactly` fixes this, but it does.\n *\n * */\ntype Exactly<Parent, Child> = Parent & {\n  [K in keyof Child]: K extends keyof Parent ? Child[K] : never;\n};\n\n// ==========\n// InstaQL helpers\n\ntype InstaQLEntitySubqueryResult<\n  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,\n  EntityName extends keyof Schema['entities'],\n  Query extends InstaQLEntitySubquery<Schema, EntityName> = {},\n  UseDates extends boolean = false,\n> = {\n  [QueryPropName in keyof Query]: Schema['entities'][EntityName]['links'][QueryPropName] extends LinkAttrDef<\n    infer Cardinality,\n    infer LinkedEntityName\n  >\n    ? LinkedEntityName extends keyof Schema['entities']\n      ? Cardinality extends 'one'\n        ?\n            | InstaQLEntity<\n                Schema,\n                LinkedEntityName,\n                Remove$NonRecursive<Query[QueryPropName]>,\n                Query[QueryPropName]['$']['fields'],\n                UseDates\n              >\n            | undefined\n        : InstaQLEntity<\n            Schema,\n            LinkedEntityName,\n            Remove$NonRecursive<Query[QueryPropName]>,\n            Query[QueryPropName]['$']['fields'],\n            UseDates\n          >[]\n      : never\n    : never;\n};\n\ntype InstaQLQueryEntityLinksResult<\n  Entities extends EntitiesDef,\n  EntityName extends keyof Entities,\n  Query extends {\n    [LinkAttrName in keyof Entities[EntityName]['links']]?: any;\n  },\n  WithCardinalityInference extends boolean,\n  UseDates extends boolean = false,\n> = {\n  [QueryPropName in keyof Query]: Entities[EntityName]['links'][QueryPropName] extends LinkAttrDef<\n    infer Cardinality,\n    infer LinkedEntityName\n  >\n    ? LinkedEntityName extends keyof Entities\n      ? WithCardinalityInference extends true\n        ? Cardinality extends 'one'\n          ?\n              | InstaQLQueryEntityResult<\n                  Entities,\n                  LinkedEntityName,\n                  Query[QueryPropName],\n                  WithCardinalityInference,\n                  UseDates\n                >\n              | undefined\n          : InstaQLQueryEntityResult<\n              Entities,\n              LinkedEntityName,\n              Query[QueryPropName],\n              WithCardinalityInference,\n              UseDates\n            >[]\n        : InstaQLQueryEntityResult<\n            Entities,\n            LinkedEntityName,\n            Query[QueryPropName],\n            WithCardinalityInference,\n            UseDates\n          >[]\n      : never\n    : never;\n};\n\n// Pick, but applies the pick to each union\ntype DistributePick<T, K extends string> = T extends any\n  ? { [P in K]: P extends keyof T ? T[P] : never }\n  : never;\n\ntype InstaQLFields<\n  S extends IContainEntitiesAndLinks<any, any>,\n  K extends keyof S['entities'],\n> = (Extract<keyof ResolveEntityAttrs<S['entities'][K]>, string> | 'id')[];\n\ntype InstaQLEntity<\n  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,\n  EntityName extends keyof Schema['entities'],\n  Subquery extends InstaQLEntitySubquery<Schema, EntityName> = {},\n  Fields extends InstaQLFields<Schema, EntityName> | undefined = undefined,\n  UseDates extends boolean = false,\n> = Expand<\n  { id: string } & (Extract<Fields[number], string> extends undefined\n    ? ResolveEntityAttrs<Schema['entities'][EntityName], UseDates>\n    : DistributePick<\n        ResolveEntityAttrs<Schema['entities'][EntityName], UseDates>,\n        Exclude<Fields[number], 'id'>\n      >) &\n    InstaQLEntitySubqueryResult<Schema, EntityName, Subquery, UseDates>\n>;\n\ntype InstaQLQueryEntityResult<\n  Entities extends EntitiesDef,\n  EntityName extends keyof Entities,\n  Query extends {\n    [QueryPropName in keyof Entities[EntityName]['links']]?: any;\n  },\n  WithCardinalityInference extends boolean,\n  UseDates extends boolean,\n> = { id: string } & ResolveAttrs<Entities, EntityName, UseDates> &\n  InstaQLQueryEntityLinksResult<\n    Entities,\n    EntityName,\n    Query,\n    WithCardinalityInference,\n    UseDates\n  >;\n\ntype InstaQLQueryResult<\n  Entities extends EntitiesDef,\n  Query,\n  WithCardinalityInference extends boolean,\n  UseDates extends boolean,\n> = {\n  [QueryPropName in keyof Query]: QueryPropName extends keyof Entities\n    ? InstaQLQueryEntityResult<\n        Entities,\n        QueryPropName,\n        Query[QueryPropName],\n        WithCardinalityInference,\n        UseDates\n      >[]\n    : never;\n};\n\ntype InstaQLResult<\n  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,\n  Query extends InstaQLParams<Schema>,\n  UseDates extends boolean = false,\n> = Expand<{\n  [QueryPropName in keyof Query]: QueryPropName extends keyof Schema['entities']\n    ? InstaQLEntity<\n        Schema,\n        QueryPropName,\n        Remove$NonRecursive<Query[QueryPropName]>,\n        Query[QueryPropName]['$']['fields'],\n        UseDates\n      >[]\n    : never;\n}>;\n\ntype InstaQLEntitySubquery<\n  Schema extends IContainEntitiesAndLinks<EntitiesDef, any>,\n  EntityName extends keyof Schema['entities'],\n> = {\n  [QueryPropName in keyof Schema['entities'][EntityName]['links']]?:\n    | $Option<Schema, EntityName>\n    | ($Option<Schema, EntityName> &\n        InstaQLEntitySubquery<\n          Schema,\n          Schema['entities'][EntityName]['links'][QueryPropName]['entityName']\n        >);\n};\n\ntype InstaQLQuerySubqueryParams<\n  S extends IContainEntitiesAndLinks<any, any>,\n  E extends keyof S['entities'],\n> = {\n  [K in keyof S['entities'][E]['links']]?:\n    | $Option<S, S['entities'][E]['links'][K]['entityName']>\n    | ($Option<S, S['entities'][E]['links'][K]['entityName']> &\n        InstaQLQuerySubqueryParams<\n          S,\n          S['entities'][E]['links'][K]['entityName']\n        >);\n};\n\ntype InstaQLParams<S extends IContainEntitiesAndLinks<any, any>> = {\n  [K in keyof S['entities']]?:\n    | $Option<S, K>\n    | ($Option<S, K> & InstaQLQuerySubqueryParams<S, K>);\n};\n\n/**\n * @deprecated\n * `InstaQLQueryParams` is deprecated. Use `InstaQLParams` instead.\n *\n * @example\n * // Before\n * const myQuery = {...} satisfies InstaQLQueryParams<Schema>\n * // After\n * const myQuery = {...} satisfies InstaQLParams<Schema>\n */\ntype InstaQLQueryParams<S extends IContainEntitiesAndLinks<any, any>> =\n  InstaQLParams<S>;\n\ntype InstaQLOptions = {\n  ruleParams: RuleParams;\n};\n\n// Start of new types\n\ntype ValidQueryObject<\n  T extends Record<string, any>,\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n  TopLevel extends boolean,\n> = keyof T extends keyof Schema['entities'][EntityName]['links'] | '$'\n  ? {\n      [K in keyof Schema['entities'][EntityName]['links']]?: ValidQueryObject<\n        T[K],\n        Schema,\n        Schema['entities'][EntityName]['links'][K]['entityName'],\n        false\n      >;\n    } & {\n      $?: ValidDollarSignQuery<T['$'], Schema, EntityName, TopLevel>;\n    }\n  : never;\n\ntype PaginationKeys =\n  | 'limit'\n  | 'last'\n  | 'first'\n  | 'offset'\n  | 'after'\n  | 'before';\n\ntype AllowedDollarSignKeys<TopLevel extends boolean> = TopLevel extends true\n  ? PaginationKeys | 'where' | 'fields' | 'order'\n  : 'where' | 'fields' | 'order' | 'limit';\n\ntype ValidFieldNames<\n  S extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof S['entities'],\n> = Extract<keyof ResolveEntityAttrs<S['entities'][EntityName]>, string> | 'id';\n\ntype ValidDollarSignQuery<\n  Input extends { [key: string]: any },\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n  TopLevel extends boolean,\n> =\n  keyof Input extends AllowedDollarSignKeys<TopLevel>\n    ? {\n        where?: ValidWhereObject<Input['where'], Schema, EntityName>;\n        fields?: ValidFieldNames<Schema, EntityName>[];\n        order?: Order<Schema, EntityName>;\n      } & (TopLevel extends true\n        ? {\n            limit?: number;\n            last?: number;\n            first?: number;\n            offset?: number;\n            after?: Cursor;\n            before?: Cursor;\n          }\n        : {})\n    : never;\n\ntype StringifiableKey<T> = Extract<T, string | number | bigint | boolean>;\n\ntype ValidWhereNestedPath<\n  T,\n  K extends string | number | symbol,\n  Schema extends IContainEntitiesAndLinks<any, any>,\n> = T extends object\n  ? K extends keyof T\n    ? K // Allow link names as valid paths (they'll default to id)\n    : K extends `${infer K0}.${infer KR}`\n      ? K0 extends keyof T\n        ? T[K0] extends keyof Schema['entities']\n          ? `${K0}.${\n              | ValidWhereNestedPath<\n                  {\n                    [K in keyof Schema['entities'][T[K0]]['links']]: Schema['entities'][T[K0]]['links'][K]['entityName'];\n                  },\n                  KR,\n                  Schema\n                >\n              | StringifiableKey<keyof Schema['entities'][T[K0]]['attrs']>\n              | 'id'}`\n          : string & keyof T\n        : string & keyof T\n      : string & keyof T\n  : never;\n\ntype ValidDotPath<\n  Input extends string | number | symbol,\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> = ValidWhereNestedPath<\n  {\n    [K in keyof Schema['entities'][EntityName]['links']]: Schema['entities'][EntityName]['links'][K]['entityName'];\n  },\n  Input,\n  Schema\n>;\n\ntype WhereOperatorObject<Input, V, R, I> = keyof Input extends\n  | keyof BaseWhereClauseValueComplex<V>\n  | '$ilike'\n  | '$like'\n  | '$isNull'\n  ? BaseWhereClauseValueComplex<V> &\n      (IsAny<V> extends true\n        ? {\n            $ilike?: string;\n            $like?: string;\n            $isNull?: boolean;\n          }\n        : (V extends string\n            ? {\n                $like?: string;\n              }\n            : {}) &\n            (R extends false\n              ? {\n                  $isNull?: boolean;\n                }\n              : {}) &\n            (I extends true\n              ? {\n                  $ilike?: string;\n                }\n              : {}))\n  : never;\n\ntype ValidWhereValue<Input, AttrDef extends DataAttrDef<any, any, any>> =\n  AttrDef extends DataAttrDef<infer V, infer R, infer I>\n    ? Input extends V\n      ? V\n      : NonEmpty<WhereOperatorObject<Input, V, R, I>>\n    : never;\n\ntype NoDistribute<T> = [T] extends [any] ? T : never;\n\ntype ValidWhereObject<\n  Input extends { [key: string]: any } | undefined,\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> = Input extends undefined\n  ? undefined\n  : keyof Input extends\n        | ValidDotPath<keyof Input, Schema, EntityName>\n        | keyof Schema['entities'][EntityName]['attrs']\n        | 'and'\n        | 'or'\n        | 'id'\n    ? {\n        [K in ValidDotPath<keyof Input, Schema, EntityName>]?: ValidWhereValue<\n          Input[K],\n          ExtractAttrFromDotPath<K, Schema, EntityName>\n        >;\n      } & {\n        [K in keyof Schema['entities'][EntityName]['attrs']]?: ValidWhereValue<\n          Input[K],\n          Schema['entities'][EntityName]['attrs'][K]\n        >;\n      } & {\n        and?: Input extends { and: Array<infer Item> }\n          ? ValidWhereObject<NoDistribute<Item>, Schema, EntityName>[]\n          : never;\n        or?: Input extends { or: Array<infer Item> }\n          ? ValidWhereObject<NoDistribute<Item>, Schema, EntityName>[]\n          : never;\n      } & {\n        // Special case for id\n        id?: ValidWhereValue<Input['id'], DataAttrDef<string, false, false>>;\n      }\n    : never;\n\n/**\n * Extracts the attribute definition from a valid dot path.\n * Given a dot path like \"user.posts.title\", this will resolve to the type of the \"title\" attribute.\n * If the path is just a link name (e.g., \"posts\"), it defaults to the id field.\n * Returns DataAttrDef or never\n */\ntype ExtractAttrFromDotPath<\n  Path extends string | number | symbol,\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema['entities'],\n> = Path extends keyof Schema['entities'][EntityName]['attrs']\n  ? Schema['entities'][EntityName]['attrs'][Path]\n  : Path extends 'id'\n    ? DataAttrDef<string, false, false>\n    : Path extends `${infer LinkName}.${infer RestPath}`\n      ? LinkName extends keyof Schema['entities'][EntityName]['links']\n        ? ExtractAttrFromDotPath<\n            RestPath,\n            Schema,\n            Schema['entities'][EntityName]['links'][LinkName]['entityName']\n          >\n        : never\n      : Path extends keyof Schema['entities'][EntityName]['links']\n        ? DataAttrDef<string, false, false>\n        : never;\n\ntype ValidQuery<\n  Q extends object,\n  S extends IContainEntitiesAndLinks<any, any>,\n> = S extends InstantUnknownSchemaDef\n  ? InstaQLParams<S>\n  : keyof Q extends keyof S['entities']\n    ? {\n        [K in keyof S['entities']]?: ValidQueryObject<Q[K], S, K, true>;\n      }\n    : never;\n\nexport {\n  Query,\n  QueryResponse,\n  InstaQLResponse,\n  PageInfoResponse,\n  InstantObject,\n  Exactly,\n  Remove$,\n  ValidQuery,\n  InstaQLQueryResult,\n  InstaQLParams,\n  InstaQLOptions,\n  InstaQLQueryEntityResult,\n  InstaQLEntitySubquery,\n  InstaQLEntity,\n  InstaQLResult,\n  InstaQLFields,\n  Cursor,\n  InstaQLQueryParams,\n};\n"]}