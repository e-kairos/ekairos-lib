{"version":3,"file":"dates.js","sourceRoot":"","sources":["../../../src/utils/dates.ts"],"names":[],"mappings":"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","sourcesContent":["import { pgTimezoneMatch, pgTimezoneAbbrevs } from './pgtime.ts';\n\n// Date parsing functions\nfunction zonedDateTimeStrToInstant(s) {\n  return new Date(s);\n}\n\nfunction localDateTimeStrToInstant(s) {\n  // Parse as UTC since there's no timezone info\n  return new Date(s + 'Z');\n}\n\nconst localDateStrRe = /^(\\d+)[\\./-](\\d+)[\\./-](\\d+)$/;\n\nfunction localDateStrToInstant(s) {\n  const match = s.match(localDateStrRe);\n  if (!match) {\n    return null;\n  }\n\n  const [_, part1, part2, part3] = match;\n\n  if (part1 <= 0 || part2 <= 0 || part3 <= 0) {\n    return null;\n  }\n\n  if (part1 > 999) {\n    return new Date(Date.UTC(part1, part2 - 1, part3, 0, 0, 0, 0));\n  }\n  return new Date(Date.UTC(part3, part1 - 1, part2, 0, 0, 0, 0));\n}\n\n// Custom date formatters\nfunction offioDateStrToInstant(s) {\n  // Format: \"yyyy-MM-dd HH:mm:ss\"\n  // Treat as UTC\n  const [datePart, timePart] = s.split(' ');\n  return new Date(datePart + 'T' + timePart + 'Z');\n}\n\nfunction zenecaDateStrToInstant(s) {\n  // Format: \"yyyy-MM-dd HH:mm:ss.n\"\n  // Treat as UTC\n  const [datePart, timeWithNanos] = s.split(' ');\n  // JavaScript Date can handle fractional seconds\n  return new Date(datePart + 'T' + timeWithNanos + 'Z');\n}\n\nfunction rfc1123ToInstant(s) {\n  // RFC 1123 format is natively supported by Date constructor\n  return new Date(s);\n}\n\nfunction dowMonDayYearStrToInstant(s) {\n  // Format: \"EEE MMM dd yyyy\" (e.g., \"Wed Jan 15 2025\")\n\n  //Only parse if the string is in the correct format\n  const regex = /^(\\w{3}) (\\w{3}) (\\d{2}) (\\d{4})$/;\n  const match = s.match(regex);\n\n  if (!match) {\n    throw new Error(`Unable to parse \\`${s}\\` as a date.`);\n  }\n\n  const date = new Date(s + ' UTC'); // Force UTC parsing\n  return new Date(\n    Date.UTC(\n      date.getUTCFullYear(),\n      date.getUTCMonth(),\n      date.getUTCDate(),\n      0,\n      0,\n      0,\n      0,\n    ),\n  );\n}\n\nfunction iso8601IncompleteOffsetToInstant(s) {\n  // Format: \"2025-01-02T00:00:00-08\" (missing minutes in timezone offset)\n  // Convert to proper ISO 8601 format by adding \":00\" to the timezone offset\n  const regex = /^(.+T.+)([+-])(\\d{2})$/;\n  const match = s.match(regex);\n\n  if (match) {\n    const [, dateTimePart, sign, hours] = match;\n    const correctedString = `${dateTimePart}${sign}${hours}:00`;\n    return new Date(correctedString);\n  }\n\n  return null;\n}\n\nfunction usDateTimeStrToInstant(s) {\n  // Format: \"M/d/yyyy, h:mm:ss a\" (e.g., \"8/4/2025, 11:02:31 PM\")\n  const [datePart, timePart] = s.split(', ');\n  const [month, day, year] = datePart.split('/').map(Number);\n\n  // Parse time with AM/PM\n  const timeMatch = timePart.match(/(\\d{1,2}):(\\d{2}):(\\d{2}) (AM|PM)/);\n  if (!timeMatch) {\n    throw new Error(`Unable to parse time from: ${s}`);\n  }\n\n  let [, hours, minutes, seconds, ampm] = timeMatch;\n  hours = Number(hours);\n  minutes = Number(minutes);\n  seconds = Number(seconds);\n\n  // Convert 12-hour to 24-hour format\n  if (ampm === 'PM' && hours !== 12) {\n    hours += 12;\n  } else if (ampm === 'AM' && hours === 12) {\n    hours = 0;\n  }\n\n  // Create date in UTC\n  return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));\n}\n\n// https://www.postgresql.org/docs/17/datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-VALUES\nfunction specialStrToInstant(s: string) {\n  switch (s) {\n    case 'epoch':\n      return new Date(0);\n    // These are not implemented yet because we need some way for the\n    // client and server to aggree on the values\n    case 'infinity':\n    case '-infinity':\n    case 'today':\n    case 'tomorrow':\n    case 'yesterday':\n      return null;\n  }\n}\n\nfunction pgTimezoneStrToInstant(s: string) {\n  const match = s.match(pgTimezoneMatch);\n  if (!match) {\n    return null;\n  }\n  const [tz] = match;\n\n  const offset = pgTimezoneAbbrevs[tz];\n\n  const baseDate = new Date(s.replace(pgTimezoneMatch, 'Z'));\n\n  return new Date(baseDate.getTime() - offset * 1000);\n}\n\n// Array of parsers\nconst dateParsers = [\n  localDateStrToInstant,\n  zenecaDateStrToInstant,\n  dowMonDayYearStrToInstant,\n  usDateTimeStrToInstant,\n  rfc1123ToInstant,\n  localDateTimeStrToInstant,\n  iso8601IncompleteOffsetToInstant,\n  offioDateStrToInstant,\n  zonedDateTimeStrToInstant,\n  specialStrToInstant,\n  pgTimezoneStrToInstant,\n];\n\n// Try to parse with a specific parser\nfunction tryParseDateString(parser, s: string) {\n  try {\n    const result = parser(s);\n    // Check if result is valid date\n    if (result instanceof Date && !isNaN(result.getTime())) {\n      return result;\n    }\n    return null;\n  } catch (e) {\n    return null;\n  }\n}\n\n// Try all parsers until one succeeds\nfunction dateStrToInstant(s) {\n  for (const parser of dateParsers) {\n    const instant = tryParseDateString(parser, s);\n    if (instant) {\n      return instant;\n    }\n  }\n  return null;\n}\n\n// Parse JSON string and then try date parsing\nfunction jsonStrToInstant(maybeJson: string) {\n  try {\n    const s = JSON.parse(maybeJson);\n    if (typeof s === 'string') {\n      return dateStrToInstant(s);\n    }\n    return null;\n  } catch (e) {\n    return null;\n  }\n}\n\n// Main parse function that handles strings and numbers\nexport function coerceToDate(x: unknown): Date | null | undefined {\n  if (x === undefined) {\n    return undefined;\n  }\n  if (x === null) {\n    return null;\n  }\n\n  if (x instanceof Date) {\n    return x;\n  }\n  if (typeof x === 'string') {\n    const result =\n      dateStrToInstant(x) || jsonStrToInstant(x) || dateStrToInstant(x.trim());\n    if (!result) {\n      throw new Error(`Unable to parse \\`${x}\\` as a date.`);\n    }\n    return result;\n  } else if (typeof x === 'number') {\n    return new Date(x);\n  }\n  throw new Error(\n    `Invalid date value \\`${x}\\`. Expected a date, number, or string, got type ${typeof x}.`,\n  );\n}\n"]}