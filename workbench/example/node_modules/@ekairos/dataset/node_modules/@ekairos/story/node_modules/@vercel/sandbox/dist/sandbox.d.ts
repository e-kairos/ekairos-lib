import type { SandboxMetaData, SandboxRouteData } from "./api-client";
import type { Writable } from "stream";
import { APIClient } from "./api-client";
import { Command, type CommandFinished } from "./command";
import { type Credentials } from "./utils/get-credentials";
import { WithPrivate } from "./utils/types";
/** @inline */
export interface CreateSandboxParams {
    /**
     * The source of the sandbox.
     *
     * Omit this parameter start a sandbox without a source.
     *
     * For git sources:
     * - `depth`: Creates shallow clones with limited commit history (minimum: 1)
     * - `revision`: Clones and checks out a specific commit, branch, or tag
     */
    source?: {
        type: "git";
        url: string;
        depth?: number;
        revision?: string;
    } | {
        type: "git";
        url: string;
        username: string;
        password: string;
        depth?: number;
        revision?: string;
    } | {
        type: "tarball";
        url: string;
    };
    /**
     * Array of port numbers to expose from the sandbox. Sandboxes can
     * expose up to 4 ports.
     */
    ports?: number[];
    /**
     * Timeout in milliseconds before the sandbox auto-terminates.
     */
    timeout?: number;
    /**
     * Resources to allocate to the sandbox.
     *
     * Your sandbox will get the amount of vCPUs you specify here and
     * 2048 MB of memory per vCPU.
     */
    resources?: {
        vcpus: number;
    };
    /**
     * The runtime of the sandbox, currently only `node22` and `python3.13` are supported.
     * If not specified, the default runtime `node22` will be used.
     */
    runtime?: "node22" | "python3.13" | (string & {});
    /**
     * An AbortSignal to cancel sandbox creation.
     */
    signal?: AbortSignal;
}
/** @inline */
interface GetSandboxParams {
    /**
     * Unique identifier of the sandbox.
     */
    sandboxId: string;
    /**
     * An AbortSignal to cancel the operation.
     */
    signal?: AbortSignal;
}
/** @inline */
interface RunCommandParams {
    /**
     * The command to execute
     */
    cmd: string;
    /**
     * Arguments to pass to the command
     */
    args?: string[];
    /**
     * Working directory to execute the command in
     */
    cwd?: string;
    /**
     * Environment variables to set for this command
     */
    env?: Record<string, string>;
    /**
     * If true, execute this command with root privileges. Defaults to false.
     */
    sudo?: boolean;
    /**
     * If true, the command will return without waiting for `exitCode`
     */
    detached?: boolean;
    /**
     * A `Writable` stream where `stdout` from the command will be piped
     */
    stdout?: Writable;
    /**
     * A `Writable` stream where `stderr` from the command will be piped
     */
    stderr?: Writable;
    /**
     * An AbortSignal to cancel the command execution
     */
    signal?: AbortSignal;
}
/**
 * A Sandbox is an isolated Linux MicroVM to run commands in.
 *
 * Use {@link Sandbox.create} or {@link Sandbox.get} to construct.
 * @hideconstructor
 */
export declare class Sandbox {
    private readonly client;
    /**
     * Routes from ports to subdomains.
    /* @hidden
     */
    readonly routes: SandboxRouteData[];
    /**
     * Unique ID of this sandbox.
     */
    get sandboxId(): string;
    /**
     * The status of the sandbox.
     */
    get status(): SandboxMetaData["status"];
    /**
     * The timeout of the sandbox in milliseconds.
     */
    get timeout(): number;
    /**
     * Internal metadata about this sandbox.
     */
    private sandbox;
    /**
     * Allow to get a list of sandboxes for a team narrowed to the given params.
     * It returns both the sandboxes and the pagination metadata to allow getting
     * the next page of results.
     */
    static list(params: Parameters<APIClient["listSandboxes"]>[0] & Partial<Credentials>): Promise<import("./api-client/base-client").Parsed<{
        sandboxes: {
            region: string;
            status: "pending" | "running" | "stopping" | "stopped" | "failed";
            timeout: number;
            cwd: string;
            id: string;
            memory: number;
            vcpus: number;
            runtime: string;
            requestedAt: number;
            createdAt: number;
            updatedAt: number;
            duration?: number | undefined;
            startedAt?: number | undefined;
            requestedStopAt?: number | undefined;
            stoppedAt?: number | undefined;
        }[];
        pagination: {
            count: number;
            next: number | null;
            prev: number | null;
        };
    }>>;
    /**
     * Create a new sandbox.
     *
     * @param params - Creation parameters and optional credentials.
     * @returns A promise resolving to the created {@link Sandbox}.
     */
    static create(params?: WithPrivate<CreateSandboxParams | (CreateSandboxParams & Credentials)>): Promise<Sandbox>;
    /**
     * Retrieve an existing sandbox.
     *
     * @param params - Get parameters and optional credentials.
     * @returns A promise resolving to the {@link Sandbox}.
     */
    static get(params: GetSandboxParams | (GetSandboxParams & Credentials)): Promise<Sandbox>;
    /**
     * Create a new Sandbox instance.
     *
     * @param client - API client used to communicate with the backend
     * @param routes - Port-to-subdomain mappings for exposed ports
     * @param sandboxId - Unique identifier for the sandbox
     */
    constructor({ client, routes, sandbox, }: {
        client: APIClient;
        routes: SandboxRouteData[];
        sandbox: SandboxMetaData;
    });
    /**
     * Get a previously run command by its ID.
     *
     * @param cmdId - ID of the command to retrieve
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A {@link Command} instance representing the command
     */
    getCommand(cmdId: string, opts?: {
        signal?: AbortSignal;
    }): Promise<Command>;
    /**
     * Start executing a command in this sandbox.
     *
     * @param command - The command to execute.
     * @param args - Arguments to pass to the command.
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the command execution.
     * @returns A {@link CommandFinished} result once execution is done.
     */
    runCommand(command: string, args?: string[], opts?: {
        signal?: AbortSignal;
    }): Promise<CommandFinished>;
    /**
     * Start executing a command in detached mode.
     *
     * @param params - The command parameters.
     * @returns A {@link Command} instance for the running command.
     */
    runCommand(params: RunCommandParams & {
        detached: true;
    }): Promise<Command>;
    /**
     * Start executing a command in this sandbox.
     *
     * @param params - The command parameters.
     * @returns A {@link CommandFinished} result once execution is done.
     */
    runCommand(params: RunCommandParams): Promise<CommandFinished>;
    /**
     * Internal helper to start a command in the sandbox.
     *
     * @param params - Command execution parameters.
     * @returns A {@link Command} or {@link CommandFinished}, depending on `detached`.
     * @internal
     */
    _runCommand(params: RunCommandParams): Promise<Command | CommandFinished>;
    /**
     * Create a directory in the filesystem of this sandbox.
     *
     * @param path - Path of the directory to create
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     */
    mkDir(path: string, opts?: {
        signal?: AbortSignal;
    }): Promise<void>;
    /**
     * Read a file from the filesystem of this sandbox.
     *
     * @param file - File to read, with path and optional cwd
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves to a ReadableStream containing the file contents
     */
    readFile(file: {
        path: string;
        cwd?: string;
    }, opts?: {
        signal?: AbortSignal;
    }): Promise<NodeJS.ReadableStream | null>;
    /**
     * Write files to the filesystem of this sandbox.
     * Defaults to writing to /vercel/sandbox unless an absolute path is specified.
     * Writes files using the `vercel-sandbox` user.
     *
     * @param files - Array of files with path and stream/buffer contents
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the files are written
     */
    writeFiles(files: {
        path: string;
        content: Buffer;
    }[], opts?: {
        signal?: AbortSignal;
    }): Promise<void>;
    /**
     * Get the public domain of a port of this sandbox.
     *
     * @param p - Port number to resolve
     * @returns A full domain (e.g. `https://subdomain.vercel.run`)
     * @throws If the port has no associated route
     */
    domain(p: number): string;
    /**
     * Stop the sandbox.
     *
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the sandbox is stopped
     */
    stop(opts?: {
        signal?: AbortSignal;
    }): Promise<void>;
    /**
     * Extend the timeout of the sandbox by the specified duration.
     *
     * This allows you to extend the lifetime of a sandbox up until the maximum
     * execution timeout for your plan.
     *
     * @param duration - The duration in milliseconds to extend the timeout by
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the timeout is extended
     */
    extendTimeout(duration: number, opts?: {
        signal?: AbortSignal;
    }): Promise<void>;
}
export {};
