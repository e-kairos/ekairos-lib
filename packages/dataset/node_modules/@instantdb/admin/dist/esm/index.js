var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { tx, lookup, getOps, i, id, txInit, version as coreVersion, InstantAPIError, validateQuery, validateTransactions, } from '@instantdb/core';
import version from "./version.js";
import { subscribe, } from "./subscribe.js";
function configWithDefaults(config) {
    const defaultConfig = {
        apiURI: 'https://api.instantdb.com',
    };
    const r = Object.assign(Object.assign({}, defaultConfig), config);
    return r;
}
function instantConfigWithDefaults(config) {
    const defaultConfig = {
        apiURI: 'https://api.instantdb.com',
    };
    const r = Object.assign(Object.assign({}, defaultConfig), config);
    return r;
}
function withImpersonation(headers, opts) {
    if ('email' in opts) {
        headers['as-email'] = opts.email;
    }
    else if ('token' in opts) {
        headers['as-token'] = opts.token;
    }
    else if ('guest' in opts) {
        headers['as-guest'] = 'true';
    }
    return headers;
}
function validateConfigAndImpersonation(config, impersonationOpts) {
    if (impersonationOpts &&
        ('token' in impersonationOpts || 'guest' in impersonationOpts)) {
        // adminToken is not required for `token` or `guest` impersonation
        return;
    }
    if (config.adminToken) {
        // An adminToken is provided.
        return;
    }
    if (impersonationOpts && 'email' in impersonationOpts) {
        throw new Error('Admin token required. To impersonate users with an email you must pass `adminToken` to `init`.');
    }
    throw new Error('Admin token required. To run this operation pass `adminToken` to `init`, or use `db.asUser`.');
}
function authorizedHeaders(config, impersonationOpts) {
    validateConfigAndImpersonation(config, impersonationOpts);
    const { adminToken, appId } = config;
    const headers = {
        'content-type': 'application/json',
        'app-id': appId,
    };
    if (adminToken) {
        headers.authorization = `Bearer ${adminToken}`;
    }
    return impersonationOpts
        ? withImpersonation(headers, impersonationOpts)
        : headers;
}
// NextJS 13 and 14 cache fetch requests by default.
//
// Since adminDB.query uses fetch, this means that it would also cache by default.
//
// We don't want this behavior. `adminDB.query` should return the latest result by default.
//
// To get around this, we set an explicit `cache` header for NextJS 13 and 14.
// This is no longer needed in NextJS 15 onwards, as the default is `no-store` again.
// Once NextJS 13 and 14 are no longer common, we can remove this code.
function isNextJSVersionThatCachesFetchByDefault() {
    return (
    // NextJS 13 onwards added a `__nextPatched` property to the fetch function
    fetch['__nextPatched'] &&
        // NextJS 15 onwards _also_ added a global `next-patch` symbol.
        !globalThis[Symbol.for('next-patch')]);
}
function getDefaultFetchOpts() {
    return isNextJSVersionThatCachesFetchByDefault() ? { cache: 'no-store' } : {};
}
function jsonReject(rejectFn, res) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = yield res.text();
        try {
            const json = JSON.parse(body);
            return rejectFn(new InstantAPIError({ status: res.status, body: json }));
        }
        catch (_e) {
            return rejectFn(new InstantAPIError({
                status: res.status,
                body: { type: undefined, message: body },
            }));
        }
    });
}
function jsonFetch(input, init) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultFetchOpts = getDefaultFetchOpts();
        const headers = Object.assign(Object.assign({}, (init.headers || {})), { 'Instant-Admin-Version': version, 'Instant-Core-Version': coreVersion });
        const res = yield fetch(input, Object.assign(Object.assign(Object.assign({}, defaultFetchOpts), init), { headers }));
        if (res.status === 200) {
            const json = yield res.json();
            return Promise.resolve(json);
        }
        return jsonReject((x) => Promise.reject(x), res);
    });
}
/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  import { init } from "@instantdb/admin"
 *
 *  const db = init({
 *    appId: process.env.INSTANT_APP_ID!,
 *    adminToken: process.env.INSTANT_APP_ADMIN_TOKEN
 *  })
 *
 *  // You can also provide a schema for type safety and editor autocomplete!
 *
 *  import { init } from "@instantdb/admin"
 *  import schema from ""../instant.schema.ts";
 *
 *  const db = init({
 *    appId: process.env.INSTANT_APP_ID!,
 *    adminToken: process.env.INSTANT_APP_ADMIN_TOKEN,
 *    schema,
 *  })
 *  // To learn more: https://instantdb.com/docs/modeling-data
 */
function init(config) {
    return new InstantAdminDatabase(config);
}
/**
 * @deprecated
 * `init_experimental` is deprecated. You can replace it with `init`.
 *
 * @example
 *
 * // Before
 * import { init_experimental } from "@instantdb/admin"
 * const db = init_experimental({  ...  });
 *
 * // After
 * import { init } from "@instantdb/admin"
 * const db = init({ ...  });
 */
const init_experimental = init;
function steps(inputChunks) {
    const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
    return chunks.flatMap(getOps);
}
class Rooms {
    constructor(config) {
        this.config = config;
    }
    getPresence(roomType, roomId) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield jsonFetch(`${this.config.apiURI}/admin/rooms/presence?room-type=${String(roomType)}&room-id=${roomId}`, {
                method: 'GET',
                headers: authorizedHeaders(this.config),
            });
            return res.sessions || {};
        });
    }
}
class Auth {
    constructor(config) {
        /**
         * Generates a magic code for the user with the given email.
         * This is useful if you want to use your own email provider
         * to send magic codes.
         *
         * @example
         *   // Generate a magic code
         *   const { code } = await db.auth.generateMagicCode({ email })
         *   // Send the magic code to the user with your own email provider
         *   await customEmailProvider.sendMagicCode(email, code)
         *
         * @see https://instantdb.com/docs/backend#custom-magic-codes
         */
        this.generateMagicCode = (email) => __awaiter(this, void 0, void 0, function* () {
            return jsonFetch(`${this.config.apiURI}/admin/magic_code`, {
                method: 'POST',
                headers: authorizedHeaders(this.config),
                body: JSON.stringify({ email }),
            });
        });
        /**
         * Sends a magic code to the user with the given email.
         * This uses Instant's built-in email provider.
         *
         * @example
         *   // Send an email to user with magic code
         *   await db.auth.sendMagicCode({ email })
         *
         * @see https://instantdb.com/docs/backend#custom-magic-codes
         */
        this.sendMagicCode = (email) => __awaiter(this, void 0, void 0, function* () {
            return jsonFetch(`${this.config.apiURI}/admin/send_magic_code`, {
                method: 'POST',
                headers: authorizedHeaders(this.config),
                body: JSON.stringify({ email }),
            });
        });
        /**
         * Verifies a magic code for the user with the given email.
         *
         * @example
         *   const user = await db.auth.verifyMagicCode({ email, code })
         *   console.log("Verified user:", user)
         *
         * @see https://instantdb.com/docs/backend#custom-magic-codes
         */
        this.verifyMagicCode = (email, code) => __awaiter(this, void 0, void 0, function* () {
            const { user } = yield jsonFetch(`${this.config.apiURI}/admin/verify_magic_code`, {
                method: 'POST',
                headers: authorizedHeaders(this.config),
                body: JSON.stringify({ email, code }),
            });
            return user;
        });
        /**
         * Creates a login token for the user with the given email.
         * If that user does not exist, we create one.
         *
         * This is often useful for writing custom auth flows.
         *
         * @example
         *   app.post('/custom_sign_in', async (req, res) => {
         *     // ... your custom flow for users
         *     const token = await db.auth.createToken(email)
         *     return res.status(200).send({ token })
         *   })
         *
         * @see https://instantdb.com/docs/backend#custom-auth
         */
        this.createToken = (email) => __awaiter(this, void 0, void 0, function* () {
            const ret = yield jsonFetch(`${this.config.apiURI}/admin/refresh_tokens`, {
                method: 'POST',
                headers: authorizedHeaders(this.config),
                body: JSON.stringify({ email }),
            });
            return ret.user.refresh_token;
        });
        /**
         * Verifies a given token and returns the associated user.
         *
         * This is often useful for writing custom endpoints, where you need
         * to authenticate users.
         *
         * @example
         *   app.post('/custom_endpoint', async (req, res) => {
         *     const user = await db.auth.verifyToken(req.headers['token'])
         *     if (!user) {
         *       return res.status(401).send('Uh oh, you are not authenticated')
         *     }
         *     // ...
         *   })
         * @see https://instantdb.com/docs/backend#custom-endpoints
         */
        this.verifyToken = (token) => __awaiter(this, void 0, void 0, function* () {
            const res = yield jsonFetch(`${this.config.apiURI}/runtime/auth/verify_refresh_token`, {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({
                    'app-id': this.config.appId,
                    'refresh-token': token,
                }),
            });
            return res.user;
        });
        /**
         * Retrieves an app user by id, email, or refresh token.
         *
         * @example
         *   try {
         *     const user = await db.auth.getUser({ email })
         *     console.log("Found user:", user)
         *   } catch (err) {
         *     console.error("Failed to retrieve user:", err.message);
         *   }
         *
         * @see https://instantdb.com/docs/backend#retrieve-a-user
         */
        this.getUser = (params) => __awaiter(this, void 0, void 0, function* () {
            const qs = Object.entries(params)
                .map(([k, v]) => `${k}=${encodeURIComponent(v)}`)
                .join('&');
            const response = yield jsonFetch(`${this.config.apiURI}/admin/users?${qs}`, {
                method: 'GET',
                headers: authorizedHeaders(this.config),
            });
            return response.user;
        });
        /**
         * Deletes an app user by id, email, or refresh token.
         *
         * NB: This _only_ deletes the user; it does not delete all user data.
         * You will need to handle this manually.
         *
         * @example
         *   try {
         *     const deletedUser = await db.auth.deleteUser({ email })
         *     console.log("Deleted user:", deletedUser)
         *   } catch (err) {
         *     console.error("Failed to delete user:", err.message);
         *   }
         *
         * @see https://instantdb.com/docs/backend#delete-a-user
         */
        this.deleteUser = (params) => __awaiter(this, void 0, void 0, function* () {
            const qs = Object.entries(params).map(([k, v]) => `${k}=${v}`);
            const response = yield jsonFetch(`${this.config.apiURI}/admin/users?${qs}`, {
                method: 'DELETE',
                headers: authorizedHeaders(this.config),
            });
            return response.deleted;
        });
        this.config = config;
    }
    signOut(input) {
        return __awaiter(this, void 0, void 0, function* () {
            // If input is a string, we assume it's an email.
            // This is because of backwards compatibility: we used to only
            // accept email strings. Eventually we can remove this
            const params = typeof input === 'string' ? { email: input } : input;
            const config = this.config;
            yield jsonFetch(`${config.apiURI}/admin/sign_out`, {
                method: 'POST',
                headers: authorizedHeaders(config),
                body: JSON.stringify(params),
            });
        });
    }
}
const isNodeReadable = (v) => v &&
    typeof v === 'object' &&
    typeof v.pipe === 'function' &&
    typeof v.read === 'function';
const isWebReadable = (v) => v && typeof v.getReader === 'function';
/**
 * Functions to manage file storage.
 */
class Storage {
    constructor(config, impersonationOpts) {
        /**
         * Uploads file at the provided path. Accepts a Buffer or a Readable stream.
         *
         * @see https://instantdb.com/docs/storage
         * @example
         *   const buffer = fs.readFileSync('demo.png');
         *   const isSuccess = await db.storage.uploadFile('photos/demo.png', buffer);
         */
        this.uploadFile = (path_1, file_1, ...args_1) => __awaiter(this, [path_1, file_1, ...args_1], void 0, function* (path, file, metadata = {}) {
            const headers = Object.assign(Object.assign({}, authorizedHeaders(this.config, this.impersonationOpts)), { path });
            if (metadata.contentDisposition) {
                headers['content-disposition'] = metadata.contentDisposition;
            }
            // headers.content-type will become "undefined" (string)
            // if not removed from the object
            delete headers['content-type'];
            if (metadata.contentType) {
                headers['content-type'] = metadata.contentType;
            }
            let duplex;
            if (isNodeReadable(file)) {
                duplex = 'half'; // one-way stream
            }
            if (isNodeReadable(file) || isWebReadable(file)) {
                headers['content-length'] = metadata.fileSize.toString();
                if (!metadata.fileSize) {
                    throw new Error('fileSize is required in metadata when uploading streams');
                }
            }
            let options = Object.assign({ method: 'PUT', headers, body: file }, (duplex && { duplex }));
            return jsonFetch(`${this.config.apiURI}/admin/storage/upload`, options);
        });
        /**
         * Deletes a file by its path name (e.g. "photos/demo.png").
         *
         * @see https://instantdb.com/docs/storage
         * @example
         *   await db.storage.delete("photos/demo.png");
         */
        this.delete = (pathname) => __awaiter(this, void 0, void 0, function* () {
            return jsonFetch(`${this.config.apiURI}/admin/storage/files?filename=${encodeURIComponent(pathname)}`, {
                method: 'DELETE',
                headers: authorizedHeaders(this.config, this.impersonationOpts),
            });
        });
        /**
         * Deletes multiple files by their path names (e.g. "photos/demo.png", "essays/demo.txt").
         *
         * @see https://instantdb.com/docs/storage
         * @example
         *   await db.storage.deleteMany(["images/1.png", "images/2.png", "images/3.png"]);
         */
        this.deleteMany = (pathnames) => __awaiter(this, void 0, void 0, function* () {
            return jsonFetch(`${this.config.apiURI}/admin/storage/files/delete`, {
                method: 'POST',
                headers: authorizedHeaders(this.config, this.impersonationOpts),
                body: JSON.stringify({ filenames: pathnames }),
            });
        });
        /**
         * @deprecated. This method will be removed in the future. Use `uploadFile`
         * instead
         */
        this.upload = (pathname_1, file_1, ...args_1) => __awaiter(this, [pathname_1, file_1, ...args_1], void 0, function* (pathname, file, metadata = {}) {
            const { data: presignedUrl } = yield jsonFetch(`${this.config.apiURI}/admin/storage/signed-upload-url`, {
                method: 'POST',
                headers: authorizedHeaders(this.config),
                body: JSON.stringify({
                    app_id: this.config.appId,
                    filename: pathname,
                }),
            });
            const { ok } = yield fetch(presignedUrl, {
                method: 'PUT',
                body: file,
                headers: {
                    'Content-Type': metadata.contentType,
                },
            });
            return ok;
        });
        /**
         * @deprecated. This method will be removed in the future. Use `query` instead
         * @example
         * const files = await db.query({ $files: {}})
         */
        this.list = () => __awaiter(this, void 0, void 0, function* () {
            const { data } = yield jsonFetch(`${this.config.apiURI}/admin/storage/files`, {
                method: 'GET',
                headers: authorizedHeaders(this.config),
            });
            return data;
        });
        /**
         * @deprecated. getDownloadUrl will be removed in the future.
         * Use `query` instead to query and fetch for valid urls
         *
         * db.useQuery({
         *   $files: {
         *     $: {
         *       where: {
         *         path: "moop.png"
         *       }
         *     }
         *   }
         * })
         */
        this.getDownloadUrl = (pathname) => __awaiter(this, void 0, void 0, function* () {
            const { data } = yield jsonFetch(`${this.config.apiURI}/admin/storage/signed-download-url?app_id=${this.config.appId}&filename=${encodeURIComponent(pathname)}`, {
                method: 'GET',
                headers: authorizedHeaders(this.config),
            });
            return data;
        });
        this.config = config;
        this.impersonationOpts = impersonationOpts;
    }
}
/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` and `adminToken` :)
 *
 * @example
 *  const db = init({ appId: "my-app-id", adminToken: "my-admin-token" })
 */
class InstantAdminDatabase {
    constructor(_config) {
        this.tx = txInit();
        /**
         * Sometimes you want to scope queries to a specific user.
         *
         * You can provide a user's auth token, email, or impersonate a guest.
         *
         * @see https://instantdb.com/docs/backend#impersonating-users
         * @example
         *  await db.asUser({email: "stopa@instantdb.com"}).query({ goals: {} })
         */
        this.asUser = (opts) => {
            const newClient = new InstantAdminDatabase(Object.assign({}, this.config));
            newClient.impersonationOpts = opts;
            newClient.storage = new Storage(this.config, opts);
            return newClient;
        };
        /**
         * Use this to query your data!
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *  // fetch all goals
         *  await db.query({ goals: {} })
         *
         *  // goals where the title is "Get Fit"
         *  await db.query({ goals: { $: { where: { title: "Get Fit" } } } })
         *
         *  // all goals, _alongside_ their todos
         *  await db.query({ goals: { todos: {} } })
         */
        this.query = (query, opts = {}) => {
            if (query && opts && 'ruleParams' in opts) {
                query = Object.assign({ $$ruleParams: opts['ruleParams'] }, query);
            }
            if (!this.config.disableValidation) {
                validateQuery(query, this.config.schema);
            }
            const fetchOpts = opts.fetchOpts || {};
            const fetchOptsHeaders = fetchOpts['headers'] || {};
            return jsonFetch(`${this.config.apiURI}/admin/query`, Object.assign(Object.assign({}, fetchOpts), { method: 'POST', headers: Object.assign(Object.assign({}, fetchOptsHeaders), authorizedHeaders(this.config, this.impersonationOpts)), body: JSON.stringify({
                    query: query,
                    'inference?': !!this.config.schema,
                }) }));
        };
        /**
         * Use this to write data! You can create, update, delete, and link objects
         *
         * @see https://instantdb.com/docs/instaml
         *
         * @example
         *   // Create a new object in the `goals` namespace
         *   const goalId = id();
         *   db.transact(db.tx.goals[goalId].update({title: "Get fit"}))
         *
         *   // Update the title
         *   db.transact(db.tx.goals[goalId].update({title: "Get super fit"}))
         *
         *   // Delete it
         *   db.transact(db.tx.goals[goalId].delete())
         *
         *   // Or create an association:
         *   todoId = id();
         *   db.transact([
         *    db.tx.todos[todoId].update({ title: 'Go on a run' }),
         *    db.tx.goals[goalId].link({todos: todoId}),
         *  ])
         */
        this.transact = (inputChunks) => {
            if (!this.config.disableValidation) {
                validateTransactions(inputChunks, this.config.schema);
            }
            return jsonFetch(`${this.config.apiURI}/admin/transact`, {
                method: 'POST',
                headers: authorizedHeaders(this.config, this.impersonationOpts),
                body: JSON.stringify({
                    steps: steps(inputChunks),
                    'throw-on-missing-attrs?': !!this.config.schema,
                }),
            });
        };
        /**
         * Like `query`, but returns debugging information
         * for permissions checks along with the result.
         * Useful for inspecting the values returned by the permissions checks.
         * Note, this will return debug information for *all* entities
         * that match the query's `where` clauses.
         *
         * Requires a user/guest context to be set with `asUser`,
         * since permissions checks are user-specific.
         *
         * Accepts an optional configuration object with a `rules` key.
         * The provided rules will override the rules in the database for the query.
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *  await db.asUser({ guest: true }).debugQuery(
         *    { goals: {} },
         *    { rules: { goals: { allow: { read: "auth.id != null" } } }
         *  )
         */
        this.debugQuery = (query, opts) => __awaiter(this, void 0, void 0, function* () {
            if (query && opts && 'ruleParams' in opts) {
                query = Object.assign({ $$ruleParams: opts['ruleParams'] }, query);
            }
            const response = yield jsonFetch(`${this.config.apiURI}/admin/query_perms_check`, {
                method: 'POST',
                headers: authorizedHeaders(this.config, this.impersonationOpts),
                body: JSON.stringify({ query, 'rules-override': opts === null || opts === void 0 ? void 0 : opts.rules }),
            });
            return {
                result: response.result,
                checkResults: response['check-results'],
            };
        });
        /**
         * Like `transact`, but does not write to the database.
         * Returns debugging information for permissions checks.
         * Useful for inspecting the values returned by the permissions checks.
         *
         * Requires a user/guest context to be set with `asUser`,
         * since permissions checks are user-specific.
         *
         * Accepts an optional configuration object with a `rules` key.
         * The provided rules will override the rules in the database for the duration of the transaction.
         *
         * @example
         *   const goalId = id();
         *   db.asUser({ guest: true }).debugTransact(
         *      [db.tx.goals[goalId].update({title: "Get fit"})],
         *      { rules: { goals: { allow: { update: "auth.id != null" } } }
         *   )
         */
        this.debugTransact = (inputChunks, opts) => {
            return jsonFetch(`${this.config.apiURI}/admin/transact_perms_check`, {
                method: 'POST',
                headers: authorizedHeaders(this.config, this.impersonationOpts),
                body: JSON.stringify({
                    steps: steps(inputChunks),
                    'rules-override': opts === null || opts === void 0 ? void 0 : opts.rules,
                    // @ts-expect-error because we're using a private API (for now)
                    'dangerously-commit-tx': opts === null || opts === void 0 ? void 0 : opts.__dangerouslyCommit,
                }),
            });
        };
        this.config = instantConfigWithDefaults(_config);
        this.auth = new Auth(this.config);
        this.storage = new Storage(this.config, this.impersonationOpts);
        this.rooms = new Rooms(this.config);
    }
    /**
     * Use this to to get a live view of your data!
     *
     * @see https://www.instantdb.com/docs/backend
     *
     * @example
     *  // create a subscription to a query
     *  const query = { goals: { $: { where: { title: "Get Fit" } } } }
     *  const sub = db.subscribeQuery(query);
     *
     *  // iterate through the results with an async iterator
     *  for await (const payload of sub) {
     *    if (payload.error) {
     *      console.log(payload.error);
     *      // Stop the subscription
     *      sub.close();
     *    } else {
     *      console.log(payload.data);
     *    }
     *  }
     *
     *  // Stop the subscription
     *  sub.close();
     *
     *  // Create a subscription with a callback
     *  const sub = db.subscribeQuery(query, (payload) => {
     *    if (payload.error) {
     *      console.log(payload.error);
     *      // Stop the subscription
     *      sub.close();
     *    } else {
     *      console.log(payload.data);
     *    }
     *  });
     */
    subscribeQuery(query, cb, opts = {}) {
        if (query && opts && 'ruleParams' in opts) {
            query = Object.assign({ $$ruleParams: opts['ruleParams'] }, query);
        }
        if (!this.config.disableValidation) {
            validateQuery(query, this.config.schema);
        }
        const fetchOpts = opts.fetchOpts || {};
        const fetchOptsHeaders = fetchOpts['headers'] || {};
        const headers = Object.assign(Object.assign({}, fetchOptsHeaders), authorizedHeaders(this.config, this.impersonationOpts));
        const inference = !!this.config.schema;
        return subscribe(query, cb, {
            headers,
            inference,
            apiURI: this.config.apiURI,
        });
    }
}
export { init, init_experimental, id, tx, lookup, i, 
// error
InstantAPIError, };
//# sourceMappingURL=index.js.map