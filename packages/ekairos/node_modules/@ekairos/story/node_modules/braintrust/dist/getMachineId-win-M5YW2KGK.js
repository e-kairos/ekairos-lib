"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }


var _chunkVKR7HDRSjs = require('./chunk-VKR7HDRS.js');




var _chunkCDBUTZMHjs = require('./chunk-CDBUTZMH.js');

// ../../node_modules/.pnpm/@opentelemetry+resources@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/detectors/platform/node/machine-id/getMachineId-win.js
var _process = require('process'); var process = _interopRequireWildcard(_process);
async function getMachineId() {
  const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
  let command = "%windir%\\System32\\REG.exe";
  if (process.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process.env) {
    command = "%windir%\\sysnative\\cmd.exe /c " + command;
  }
  try {
    const result = await _chunkVKR7HDRSjs.execAsync.call(void 0, `${command} ${args}`);
    const parts = result.stdout.split("REG_SZ");
    if (parts.length === 2) {
      return parts[1].trim();
    }
  } catch (e) {
    _chunkCDBUTZMHjs.diag.debug(`error reading machine id: ${e}`);
  }
  return void 0;
}
var init_getMachineId_win = _chunkCDBUTZMHjs.__esm.call(void 0, {
  "../../node_modules/.pnpm/@opentelemetry+resources@2.0.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/detectors/platform/node/machine-id/getMachineId-win.js"() {
    _chunkVKR7HDRSjs.init_execAsync.call(void 0, );
    _chunkCDBUTZMHjs.init_esm.call(void 0, );
  }
});
init_getMachineId_win();


exports.getMachineId = getMachineId;
