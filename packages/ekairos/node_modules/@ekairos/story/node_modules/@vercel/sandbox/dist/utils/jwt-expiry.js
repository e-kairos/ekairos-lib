"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtExpiry = exports.OidcRefreshError = void 0;
const decode_base64_url_1 = require("./decode-base64-url");
const get_credentials_1 = require("./get-credentials");
const oidc_1 = require("@vercel/oidc");
const ms_1 = __importDefault(require("ms"));
/** Time buffer before token expiry to consider it invalid (in milliseconds) */
const BUFFER_MS = (0, ms_1.default)("5m");
class OidcRefreshError extends Error {
    constructor() {
        super(...arguments);
        this.name = "OidcRefreshError";
    }
}
exports.OidcRefreshError = OidcRefreshError;
/**
 * Expiry implementation for JWT tokens (OIDC tokens).
 * Parses the JWT once and provides fast expiry validation.
 */
class JwtExpiry {
    static fromToken(token) {
        if (!isJwtFormat(token)) {
            return null;
        }
        else {
            return new JwtExpiry(token);
        }
    }
    /**
     * Creates a new JWT expiry checker.
     *
     * @param token - The JWT token to parse
     */
    constructor(token) {
        this.token = token;
        try {
            const tokenContents = token.split(".")[1];
            this.payload = get_credentials_1.schema.parse((0, decode_base64_url_1.decodeBase64Url)(tokenContents));
            this.expiryTime = this.payload.exp || null;
        }
        catch {
            // Malformed token - treat as expired to trigger refresh
            this.expiryTime = 0;
        }
    }
    /**
     * Checks if the JWT token is valid (not expired).
     * @returns true if token is valid, false if expired or expiring soon
     */
    isValid() {
        if (this.expiryTime === null) {
            return false; // No expiry means malformed JWT
        }
        const now = Math.floor(Date.now() / 1000);
        const buffer = BUFFER_MS / 1000;
        return now + buffer < this.expiryTime;
    }
    /**
     * Gets the expiry date of the JWT token.
     *
     * @returns Date object representing when the token expires, or null if no expiry
     */
    getExpiryDate() {
        return this.expiryTime ? new Date(this.expiryTime * 1000) : null;
    }
    /**
     * Refreshes the JWT token by fetching a new OIDC token.
     *
     * @returns Promise resolving to a new JwtExpiry instance with fresh token
     */
    async refresh() {
        try {
            const freshToken = await (0, oidc_1.getVercelOidcToken)();
            return new JwtExpiry(freshToken);
        }
        catch (cause) {
            throw new OidcRefreshError("Failed to refresh OIDC token", {
                cause,
            });
        }
    }
    /**
     * Refreshes the JWT token if it's expired or expiring soon.
     */
    async tryRefresh() {
        if (this.isValid()) {
            return null; // Still valid, no need to refresh
        }
        return this.refresh();
    }
}
exports.JwtExpiry = JwtExpiry;
/**
 * Checks if a token follows JWT format (has 3 parts separated by dots).
 *
 * @param token - The token to check
 * @returns true if token appears to be a JWT, false otherwise
 */
function isJwtFormat(token) {
    return token.split(".").length === 3;
}
