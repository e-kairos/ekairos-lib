"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sandbox = void 0;
const api_client_1 = require("./api-client");
const command_1 = require("./command");
const get_credentials_1 = require("./utils/get-credentials");
const types_1 = require("./utils/types");
/**
 * A Sandbox is an isolated Linux MicroVM to run commands in.
 *
 * Use {@link Sandbox.create} or {@link Sandbox.get} to construct.
 * @hideconstructor
 */
class Sandbox {
    /**
     * Unique ID of this sandbox.
     */
    get sandboxId() {
        return this.sandbox.id;
    }
    /**
     * The status of the sandbox.
     */
    get status() {
        return this.sandbox.status;
    }
    /**
     * The timeout of the sandbox in milliseconds.
     */
    get timeout() {
        return this.sandbox.timeout;
    }
    /**
     * Allow to get a list of sandboxes for a team narrowed to the given params.
     * It returns both the sandboxes and the pagination metadata to allow getting
     * the next page of results.
     */
    static async list(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token,
        });
        return client.listSandboxes({
            ...params,
            signal: params.signal,
        });
    }
    /**
     * Create a new sandbox.
     *
     * @param params - Creation parameters and optional credentials.
     * @returns A promise resolving to the created {@link Sandbox}.
     */
    static async create(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token,
        });
        const privateParams = (0, types_1.getPrivateParams)(params);
        const sandbox = await client.createSandbox({
            source: params?.source,
            projectId: credentials.projectId,
            ports: params?.ports ?? [],
            timeout: params?.timeout,
            resources: params?.resources,
            runtime: params?.runtime,
            signal: params?.signal,
            ...privateParams,
        });
        return new Sandbox({
            client,
            sandbox: sandbox.json.sandbox,
            routes: sandbox.json.routes,
        });
    }
    /**
     * Retrieve an existing sandbox.
     *
     * @param params - Get parameters and optional credentials.
     * @returns A promise resolving to the {@link Sandbox}.
     */
    static async get(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token,
        });
        const sandbox = await client.getSandbox({
            sandboxId: params.sandboxId,
            signal: params.signal,
        });
        return new Sandbox({
            client,
            sandbox: sandbox.json.sandbox,
            routes: sandbox.json.routes,
        });
    }
    /**
     * Create a new Sandbox instance.
     *
     * @param client - API client used to communicate with the backend
     * @param routes - Port-to-subdomain mappings for exposed ports
     * @param sandboxId - Unique identifier for the sandbox
     */
    constructor({ client, routes, sandbox, }) {
        this.client = client;
        this.routes = routes;
        this.sandbox = sandbox;
    }
    /**
     * Get a previously run command by its ID.
     *
     * @param cmdId - ID of the command to retrieve
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A {@link Command} instance representing the command
     */
    async getCommand(cmdId, opts) {
        const command = await this.client.getCommand({
            sandboxId: this.sandbox.id,
            cmdId,
            signal: opts?.signal,
        });
        return new command_1.Command({
            client: this.client,
            sandboxId: this.sandbox.id,
            cmd: command.json.command,
        });
    }
    async runCommand(commandOrParams, args, opts) {
        return typeof commandOrParams === "string"
            ? this._runCommand({ cmd: commandOrParams, args, signal: opts?.signal })
            : this._runCommand(commandOrParams);
    }
    /**
     * Internal helper to start a command in the sandbox.
     *
     * @param params - Command execution parameters.
     * @returns A {@link Command} or {@link CommandFinished}, depending on `detached`.
     * @internal
     */
    async _runCommand(params) {
        const commandResponse = await this.client.runCommand({
            sandboxId: this.sandbox.id,
            command: params.cmd,
            args: params.args ?? [],
            cwd: params.cwd,
            env: params.env ?? {},
            sudo: params.sudo ?? false,
            signal: params.signal,
        });
        const command = new command_1.Command({
            client: this.client,
            sandboxId: this.sandbox.id,
            cmd: commandResponse.json.command,
        });
        if (params.stdout || params.stderr) {
            (async () => {
                for await (const log of command.logs({ signal: params.signal })) {
                    if (log.stream === "stdout") {
                        params.stdout?.write(log.data);
                    }
                    else if (log.stream === "stderr") {
                        params.stderr?.write(log.data);
                    }
                }
            })();
        }
        return params.detached ? command : command.wait({ signal: params.signal });
    }
    /**
     * Create a directory in the filesystem of this sandbox.
     *
     * @param path - Path of the directory to create
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     */
    async mkDir(path, opts) {
        await this.client.mkDir({
            sandboxId: this.sandbox.id,
            path: path,
            signal: opts?.signal,
        });
    }
    /**
     * Read a file from the filesystem of this sandbox.
     *
     * @param file - File to read, with path and optional cwd
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves to a ReadableStream containing the file contents
     */
    async readFile(file, opts) {
        return this.client.readFile({
            sandboxId: this.sandbox.id,
            path: file.path,
            cwd: file.cwd,
            signal: opts?.signal,
        });
    }
    /**
     * Write files to the filesystem of this sandbox.
     * Defaults to writing to /vercel/sandbox unless an absolute path is specified.
     * Writes files using the `vercel-sandbox` user.
     *
     * @param files - Array of files with path and stream/buffer contents
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the files are written
     */
    async writeFiles(files, opts) {
        return this.client.writeFiles({
            sandboxId: this.sandbox.id,
            cwd: this.sandbox.cwd,
            extractDir: "/",
            files: files,
            signal: opts?.signal,
        });
    }
    /**
     * Get the public domain of a port of this sandbox.
     *
     * @param p - Port number to resolve
     * @returns A full domain (e.g. `https://subdomain.vercel.run`)
     * @throws If the port has no associated route
     */
    domain(p) {
        const route = this.routes.find(({ port }) => port == p);
        if (route) {
            return `https://${route.subdomain}.vercel.run`;
        }
        else {
            throw new Error(`No route for port ${p}`);
        }
    }
    /**
     * Stop the sandbox.
     *
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the sandbox is stopped
     */
    async stop(opts) {
        await this.client.stopSandbox({
            sandboxId: this.sandbox.id,
            signal: opts?.signal,
        });
    }
    /**
     * Extend the timeout of the sandbox by the specified duration.
     *
     * This allows you to extend the lifetime of a sandbox up until the maximum
     * execution timeout for your plan.
     *
     * @param duration - The duration in milliseconds to extend the timeout by
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel the operation.
     * @returns A promise that resolves when the timeout is extended
     */
    async extendTimeout(duration, opts) {
        const response = await this.client.extendTimeout({
            sandboxId: this.sandbox.id,
            duration,
            signal: opts?.signal,
        });
        // Update the internal sandbox metadata with the new timeout value
        this.sandbox = response.json.sandbox;
    }
}
exports.Sandbox = Sandbox;
