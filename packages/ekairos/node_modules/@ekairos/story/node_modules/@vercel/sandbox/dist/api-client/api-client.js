"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIClient = void 0;
const base_client_1 = require("./base-client");
const validators_1 = require("./validators");
const api_error_1 = require("./api-error");
const file_writer_1 = require("./file-writer");
const version_1 = require("../version");
const consume_readable_1 = require("../utils/consume-readable");
const jsonlines_1 = __importDefault(require("jsonlines"));
const os_1 = __importDefault(require("os"));
const stream_1 = require("stream");
const normalizePath_1 = require("../utils/normalizePath");
const jwt_expiry_1 = require("../utils/jwt-expiry");
const types_1 = require("../utils/types");
class APIClient extends base_client_1.BaseClient {
    constructor(params) {
        super({
            host: params.host ?? "https://api.vercel.com",
            token: params.token,
            debug: false,
        });
        this.teamId = params.teamId;
        this.tokenExpiry = jwt_expiry_1.JwtExpiry.fromToken(params.token);
    }
    async ensureValidToken() {
        if (!this.tokenExpiry) {
            return;
        }
        const newExpiry = await this.tokenExpiry.tryRefresh();
        if (!newExpiry) {
            return;
        }
        this.tokenExpiry = newExpiry;
        this.token = this.tokenExpiry.token;
        if (this.tokenExpiry.payload) {
            this.teamId = this.tokenExpiry.payload?.owner_id;
        }
    }
    async request(path, params) {
        await this.ensureValidToken();
        return super.request(path, {
            ...params,
            query: { teamId: this.teamId, ...params?.query },
            headers: {
                "content-type": "application/json",
                "user-agent": `vercel/sandbox/${version_1.VERSION} (Node.js/${process.version}; ${os_1.default.platform()}/${os_1.default.arch()})`,
                ...params?.headers,
            },
        });
    }
    async getSandbox(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request(`/v1/sandboxes/${params.sandboxId}`, {
            signal: params.signal,
        }));
    }
    async createSandbox(params) {
        const privateParams = (0, types_1.getPrivateParams)(params);
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request("/v1/sandboxes", {
            method: "POST",
            body: JSON.stringify({
                projectId: params.projectId,
                ports: params.ports,
                source: params.source,
                timeout: params.timeout,
                resources: params.resources,
                runtime: params.runtime,
                ...privateParams,
            }),
            signal: params.signal,
        }));
    }
    async runCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd`, {
            method: "POST",
            body: JSON.stringify({
                command: params.command,
                args: params.args,
                cwd: params.cwd,
                env: params.env,
                sudo: params.sudo,
            }),
            signal: params.signal,
        }));
    }
    async getCommand(params) {
        return params.wait
            ? (0, base_client_1.parseOrThrow)(validators_1.CommandFinishedResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`, { signal: params.signal, query: { wait: "true" } }))
            : (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`, { signal: params.signal }));
    }
    async mkDir(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/fs/mkdir`, {
            method: "POST",
            body: JSON.stringify({ path: params.path, cwd: params.cwd }),
            signal: params.signal,
        }));
    }
    getFileWriter(params) {
        const writer = new file_writer_1.FileWriter();
        return {
            response: (async () => {
                return this.request(`/v1/sandboxes/${params.sandboxId}/fs/write`, {
                    method: "POST",
                    headers: {
                        "content-type": "application/gzip",
                        "x-cwd": params.extractDir,
                    },
                    body: await (0, consume_readable_1.consumeReadable)(writer.readable),
                    signal: params.signal,
                });
            })(),
            writer,
        };
    }
    async listSandboxes(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxesResponse, await this.request(`/v1/sandboxes`, {
            query: {
                project: params.projectId,
                limit: params.limit,
                since: typeof params.since === "number"
                    ? params.since
                    : params.since?.getTime(),
                until: typeof params.until === "number"
                    ? params.until
                    : params.until?.getTime(),
            },
            method: "GET",
            signal: params.signal,
        }));
    }
    async writeFiles(params) {
        const { writer, response } = this.getFileWriter({
            sandboxId: params.sandboxId,
            extractDir: params.extractDir,
            signal: params.signal,
        });
        for (const file of params.files) {
            await writer.addFile({
                name: (0, normalizePath_1.normalizePath)({
                    filePath: file.path,
                    extractDir: params.extractDir,
                    cwd: params.cwd,
                }),
                content: file.content,
            });
        }
        writer.end();
        await (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await response);
    }
    async readFile(params) {
        const response = await this.request(`/v1/sandboxes/${params.sandboxId}/fs/read`, {
            method: "POST",
            body: JSON.stringify({ path: params.path, cwd: params.cwd }),
            signal: params.signal,
        });
        if (response.status === 404) {
            return null;
        }
        if (response.body === null) {
            return null;
        }
        return stream_1.Readable.fromWeb(response.body);
    }
    async killCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/${params.commandId}/kill`, {
            method: "POST",
            body: JSON.stringify({ signal: params.signal }),
            signal: params.abortSignal,
        }));
    }
    getLogs(params) {
        const self = this;
        const disposer = new AbortController();
        const signal = !params.signal
            ? disposer.signal
            : mergeSignals(params.signal, disposer.signal);
        const generator = (async function* () {
            const url = `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}/logs`;
            const response = await self.request(url, {
                method: "GET",
                signal,
            });
            if (response.headers.get("content-type") !== "application/x-ndjson") {
                throw new api_error_1.APIError(response, {
                    message: "Expected a stream of logs",
                });
            }
            if (response.body === null) {
                throw new api_error_1.APIError(response, {
                    message: "No response body",
                });
            }
            const jsonlinesStream = jsonlines_1.default.parse();
            pipe(response.body, jsonlinesStream).catch((err) => {
                console.error("Error piping logs:", err);
            });
            for await (const chunk of jsonlinesStream) {
                yield validators_1.LogLine.parse(chunk);
            }
        })();
        return Object.assign(generator, {
            [Symbol.dispose]() {
                disposer.abort("Disposed");
            },
            close: () => disposer.abort("Disposed"),
        });
    }
    async stopSandbox(params) {
        const url = `/v1/sandboxes/${params.sandboxId}/stop`;
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxResponse, await this.request(url, { method: "POST", signal: params.signal }));
    }
    async extendTimeout(params) {
        const url = `/v1/sandboxes/${params.sandboxId}/extend-timeout`;
        return (0, base_client_1.parseOrThrow)(validators_1.ExtendTimeoutResponse, await this.request(url, {
            method: "POST",
            body: JSON.stringify({ duration: params.duration }),
            signal: params.signal,
        }));
    }
}
exports.APIClient = APIClient;
async function pipe(readable, output) {
    const reader = readable.getReader();
    try {
        while (true) {
            const read = await reader.read();
            if (read.value) {
                output.write(Buffer.from(read.value));
            }
            if (read.done) {
                break;
            }
        }
    }
    catch (err) {
        output.emit("error", err);
    }
    finally {
        output.end();
    }
}
function mergeSignals(...signals) {
    const controller = new AbortController();
    const onAbort = () => {
        controller.abort();
        for (const signal of signals) {
            signal.removeEventListener("abort", onAbort);
        }
    };
    for (const signal of signals) {
        if (signal.aborted) {
            controller.abort();
            break;
        }
        signal.addEventListener("abort", onAbort);
    }
    return controller.signal;
}
