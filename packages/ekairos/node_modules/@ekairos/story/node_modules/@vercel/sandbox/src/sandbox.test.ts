import { it, beforeEach, afterEach, expect } from "vitest";
import { consumeReadable } from "./utils/consume-readable";
import { Sandbox } from "./sandbox";
import { APIError } from "./api-client/api-error";
import ms from "ms";

const PORTS = [3000, 4000];
let sandbox: Sandbox;

beforeEach(async () => {
  sandbox = await Sandbox.create({ ports: PORTS });
});

afterEach(async () => {
  await sandbox.stop();
});

it("allows to write files and then read them", async () => {
  await sandbox.writeFiles([
    { path: "hello1.txt", content: Buffer.from("Hello 1") },
    { path: "hello2.txt", content: Buffer.from("Hello 2") },
  ]);

  const content1 = await sandbox.readFile({ path: "hello1.txt" });
  const content2 = await sandbox.readFile({ path: "hello2.txt" });
  expect((await consumeReadable(content1!)).toString()).toBe("Hello 1");
  expect((await consumeReadable(content2!)).toString()).toBe("Hello 2");
});

it("verifies port forwarding works correctly", async () => {
  const serverScript = `
const http = require('http');
const ports = process.argv.slice(2);

for (const port of ports) {
  const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end(\`hello port \${port}\`);
  });

  server.listen(port, () => {
    console.log(\`Server running on port \${port}\`);
  });
}
`;

  await sandbox.writeFiles([
    { path: "server.js", content: Buffer.from(serverScript) },
  ]);

  const server = await sandbox.runCommand({
    cmd: "node",
    args: ["server.js", ...PORTS.map(String)],
    detached: true,
    stdout: process.stdout,
    stderr: process.stderr,
  });

  await new Promise((resolve) => setTimeout(resolve, 1000));

  for (const port of PORTS) {
    const response = await fetch(sandbox.domain(port));
    const text = await response.text();
    expect(text).toBe(`hello port ${port}`);
  }

  await server.kill();
});

it("allows extending the sandbox timeout", async () => {
  const originalTimeout = sandbox.timeout;
  const extensionDuration = ms("5m");

  await sandbox.extendTimeout(extensionDuration);
  expect(sandbox.timeout).toEqual(originalTimeout + extensionDuration);
});

it("raises an error when the timeout cannot be updated", async () => {
  try {
    await sandbox.extendTimeout(ms("5d"));
    expect.fail("Expected extendTimeout to throw an error");
  } catch (error) {
    expect(error).toBeInstanceOf(APIError);
    expect(error).toMatchObject({
      response: { status: 400 },
      json: {
        error: { code: "sandbox_timeout_invalid" },
      },
    });
  }
});
