"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribe = subscribe;
const eventsource_1 = require("eventsource");
const version_ts_1 = __importDefault(require("./version.js"));
const core_1 = require("@instantdb/core");
function makeAsyncIterator(subscribe, subscribeOnClose, unsubscribe, readyState) {
    let wakeup = null;
    let closed = false;
    const backlog = [];
    const handler = (data) => {
        backlog.push(data);
        if (backlog.length > 100) {
            // Remove the oldest item to prevent the backlog
            // from growing forever. This is okay for live queries,
            // but we need some other machanism if we use this for
            // event-based subscriptions.
            backlog.shift();
        }
        if (wakeup) {
            wakeup();
            wakeup = null;
        }
    };
    subscribe(handler);
    const done = () => {
        unsubscribe(handler);
        return Promise.resolve({ done: true, value: undefined });
    };
    const onClose = () => {
        closed = true;
        if (wakeup) {
            wakeup();
        }
        done();
    };
    subscribeOnClose(onClose);
    const next = () => __awaiter(this, void 0, void 0, function* () {
        while (true) {
            if (readyState() === 'closed' || closed) {
                return done();
            }
            const nextValue = backlog.shift();
            if (nextValue) {
                return { value: nextValue, done: false };
            }
            const p = new Promise((resolve) => {
                wakeup = resolve;
            });
            yield p;
        }
    });
    return {
        next,
        return: done,
        throw(error) {
            unsubscribe(handler);
            return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
function esReadyState(es) {
    switch (es.readyState) {
        case es.CLOSED: {
            return 'closed';
        }
        case es.CONNECTING: {
            return 'connecting';
        }
        case es.OPEN: {
            return 'open';
        }
    }
}
function multiReadFetchResponse(r) {
    let p = null;
    return Object.assign(Object.assign({}, r), { text() {
            if (!p) {
                p = r.text();
            }
            return p;
        },
        json() {
            if (!p) {
                p = r.text();
            }
            return p.then((x) => JSON.parse(x));
        } });
}
function subscribe(query, cb, opts) {
    let fetchErrorResponse;
    let closed = false;
    const es = new eventsource_1.EventSource(`${opts.apiURI}/admin/subscribe-query`, {
        fetch(input, init) {
            fetchErrorResponse = null;
            return fetch(input, Object.assign(Object.assign({}, init), { method: 'POST', headers: opts.headers, body: JSON.stringify({
                    query: query,
                    'inference?': opts.inference,
                    versions: {
                        '@instantdb/admin': version_ts_1.default,
                        '@instantdb/core': core_1.version,
                    },
                }) })).then((r) => {
                if (!r.ok) {
                    fetchErrorResponse = multiReadFetchResponse(r);
                }
                return r;
            });
        },
    });
    const subscribers = [];
    const onCloseSubscribers = [];
    const subscribe = (cb) => {
        subscribers.push(cb);
    };
    const unsubscribe = (cb) => {
        subscribers.splice(subscribers.indexOf(cb), 1);
    };
    const subscribeOnClose = (cb) => {
        onCloseSubscribers.push(cb);
    };
    if (cb) {
        subscribe(cb);
    }
    function deliver(result) {
        if (closed) {
            return;
        }
        for (const sub of subscribers) {
            try {
                sub(result);
            }
            catch (e) {
                console.error('Error in subscribeQuery callback', e);
            }
        }
    }
    function handleMessage(msg) {
        switch (msg.op) {
            case 'add-query-ok': {
                deliver({
                    type: 'ok',
                    data: msg.result,
                });
                break;
            }
            case 'refresh-ok': {
                if (msg.computations.length) {
                    deliver({
                        type: 'ok',
                        data: msg.computations[0]['instaql-result'],
                    });
                }
                break;
            }
            case 'error': {
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({ body: msg, status: msg.status }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                });
                break;
            }
        }
    }
    es.onerror = (e) => {
        if (fetchErrorResponse) {
            fetchErrorResponse.text().then((t) => {
                let body = { type: undefined, message: t };
                try {
                    body = JSON.parse(t);
                }
                catch (_e) { }
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({
                        status: fetchErrorResponse.status,
                        body,
                    }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                });
            });
        }
        else {
            const deliverError = () => {
                deliver({
                    type: 'error',
                    error: new core_1.InstantAPIError({
                        status: e.code || 500,
                        body: {
                            type: undefined,
                            message: e.message || 'Unknown error in subscribe query.',
                        },
                    }),
                    get readyState() {
                        return esReadyState(es);
                    },
                    get isClosed() {
                        return esReadyState(es) === 'closed';
                    },
                });
            };
            if (es.readyState === eventsource_1.EventSource.CLOSED) {
                deliverError();
                return;
            }
            setTimeout(() => {
                if (es.readyState !== eventsource_1.EventSource.OPEN) {
                    deliverError();
                }
            }, 5000);
        }
    };
    es.onmessage = (e) => {
        handleMessage(JSON.parse(e.data));
    };
    const close = () => {
        closed = true;
        for (const sub of onCloseSubscribers) {
            try {
                sub();
            }
            catch (e) {
                console.error('Error in onClose callback', e);
            }
        }
        es.close();
    };
    return {
        close: close,
        [Symbol.iterator]: () => {
            throw new Error('subscribeQuery does not support synchronous iteration. Use `for await` instead.');
        },
        get readyState() {
            return esReadyState(es);
        },
        get isClosed() {
            return esReadyState(es) === 'closed';
        },
        [Symbol.asyncIterator]: makeAsyncIterator.bind(this, subscribe, subscribeOnClose, unsubscribe, () => 1),
    };
}
//# sourceMappingURL=subscribe.js.map